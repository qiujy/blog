<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>vue 源码解析二 - instance | 言川的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们从 instance/vue.js 开始:
12345678910111213141516function Vue (options) &amp;#123;  this._init(options)&amp;#125;// install internalsinitMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)miscMixin(Vue">
<meta property="og:type" content="article">
<meta property="og:title" content="vue 源码解析二 - instance">
<meta property="og:url" content="https://lihongxun945.github.io/blog/2016/09/14/devide-into-vue-2/index.html">
<meta property="og:site_name" content="言川的博客">
<meta property="og:description" content="我们从 instance/vue.js 开始:
12345678910111213141516function Vue (options) &amp;#123;  this._init(options)&amp;#125;// install internalsinitMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)miscMixin(Vue">
<meta property="og:updated_time" content="2016-09-14T08:25:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue 源码解析二 - instance">
<meta name="twitter:description" content="我们从 instance/vue.js 开始:
12345678910111213141516function Vue (options) &amp;#123;  this._init(options)&amp;#125;// install internalsinitMixin(Vue)stateMixin(Vue)eventsMixin(Vue)lifecycleMixin(Vue)miscMixin(Vue">
  
    <link rel="alternate" href="/atom.xml" title="言川的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">言川的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
          <a class="main-nav-link" href="https://github.com/lihongxun945/blog">github</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lihongxun945.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-devide-into-vue-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/09/14/devide-into-vue-2/" class="article-date">
  <time datetime="2016-09-14T02:41:00.000Z" itemprop="datePublished">2016-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      vue 源码解析二 - instance
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们从 <code>instance/vue.js</code> 开始:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// install internals</span></div><div class="line">initMixin(Vue)</div><div class="line">stateMixin(Vue)</div><div class="line">eventsMixin(Vue)</div><div class="line">lifecycleMixin(Vue)</div><div class="line">miscMixin(Vue)</div><div class="line"></div><div class="line"><span class="comment">// install instance APIs</span></div><div class="line">dataAPI(Vue)</div><div class="line">domAPI(Vue)</div><div class="line">eventsAPI(Vue)</div><div class="line">lifecycleAPI(Vue)</div></pre></td></tr></table></figure>
<p>上面这段就是 <code>vue.js</code> 中的代码，可以看到对 <code>Vue</code> 这个类的定义包含三部分：</p>
<ul>
<li><code>_init</code> 函数,做一些初始化操作，如处理父子关系，解析<code>option</code>, 启动HTML解析等</li>
<li><code>mixin</code> 大部分功能的实现都在这里</li>
<li><code>api</code> 全部的接口封装都在这里，而这些接口中部分的实现依然在 <code>mixin</code> 中</li>
</ul>
<h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h2><p>init 函数主要做了这么些工作：</p>
<ol>
<li>处理组件层级关系： <code>$parent, $chilren, $root</code></li>
<li>初始化内部变量：<code>_directives, _events, _isFragment</code> lifecircle 相关标记等</li>
<li>合并 <code>options</code>：把初始化函数传入的 <code>options</code> 和 <code>Vue.options</code> 合并，<code>Vue.options</code> 我们后续会在 global 章节详细讲解</li>
<li>调用其他模块的初始化：<code>_initState, _initEvents</code></li>
<li>启动lifecircle: <code>this.$mount</code></li>
</ol>
<p>我们这里不会每一行代码都讲到，毕竟像怎么进行 <code>dom</code> 这种并不是vue的核心所在，下面我们重点看两个关键部分：<code>数据绑定</code> 和 <code>模板更新</code></p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p><code>internal/state.js</code> 中对数据的处理代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._initState = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._initProps()</div><div class="line">  <span class="keyword">this</span>._initMeta()</div><div class="line">  <span class="keyword">this</span>._initMethods()</div><div class="line">  <span class="keyword">this</span>._initData()</div><div class="line">  <span class="keyword">this</span>._initComputed()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是 <code>state</code> 包含了五个部分：<code>props, meta, methods, data, computed</code>, 我们以 <code>props</code> 为切入点来看看数据绑定是如何工作的。</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>对 <code>props</code> 的处理，最终在 <code>src/compiler/compile-props.js</code> 中的 <code>compileProps</code> 方法中实现，这个方法过程如下：</p>
<p>第一步，对 <code>props</code> 做预处理，主要是词法分析和类型检测：</p>
<p>遍历 <code>propOptions</code> 的key，这个 <code>propOptions</code> 就是初始化传入的 <code>props</code>，然后对每一个 key 做如下操作(在循环体中叫<code>name</code>)：</p>
<ol>
<li>检查name是否是合法的标识符</li>
<li>根据 name 从 el 上取出绑定的原始值 <code>value</code>，同时会根据 <code>.sync</code> 和 <code>.once</code> 打上对应的标签</li>
<li>调用 <code>parseDirective</code> 方法解析 <code>value</code>，注意这只是一个简单的词法分析，对 <code>value</code> 做了一个切分，分出其中的 <code>expression</code> 和 <code>filter</code>，而这个 <code>expression</code> 依然是一个字符串。注意从这一步开始 <code>value</code> 和 <code>filters</code> 被分割开了</li>
<li>检查 <code>value</code> 是否是一个简单的字面量，如果是一个字面量就会打上一个 <code>optimizedLiteral</code> 标签，后序就不用处理绑定了。字面量就是以字面量形式写出的：<code>true</code>, <code>false</code>, 数字 和 字符串</li>
</ol>
<p>第一步完成后得到了一个合法的，经过初步处理的 <code>props</code> 数组。然后我们来进行第二步处理.</p>
<p>第二步主要就是把 <code>value</code> 解析出来。</p>
<p>第二步依然是一个循环处理，对第一步得到的 <code>props</code> 数组循环处理，主要是对每一个 <code>prop</code> 创建一个对应的 <code>Directive</code>：</p>
<ol>
<li>遍历 <code>props</code> 取出一个 <code>prop</code></li>
<li>在 <code>_context</code> 上进行绑定，这个 <code>_context</code> 一般就是父组件。</li>
<li>绑定的过程其实是创建了一个 <code>Directive</code>，这个 <code>Directive</code> 的 <code>descriptor</code> 如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  name: <span class="string">'prop'</span>,</div><div class="line">  prop: prop,</div><div class="line">  def: &#123;</div><div class="line">    bind: <span class="function"><span class="keyword">function</span>,</span></div><div class="line">    <span class="title">unbind</span>: <span class="title">function</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>bind</code> 和 <code>unbind</code> 是在 <code>directives/internal/prop.js</code> 中定义的。</p>
<p>到这一步我们可以明白了，对每一个 <code>prop</code> 的绑定，其实是创建了一个专门处理 <code>prop</code> 的 <code>directive</code>。那么这个 <code>directive</code> 中显然主要是处理监听的，我们继续往下看。</p>
<p>第三步，在 <code>Directive</code> 内创建 <code>watcher</code> 来监听数据更新。</p>
<p>在 <code>bind</code> 函数中创建 <code>Watcher</code> 的代码比较简洁，直接贴出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> parentWatcher = <span class="keyword">this</span>.parentWatcher = <span class="keyword">new</span> Watcher(</div><div class="line">  parent,</div><div class="line">  parentKey,</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">    updateProp(child, prop, val)</div><div class="line">  &#125;, &#123;</div><div class="line">    twoWay: twoWay,</div><div class="line">    filters: prop.filters,</div><div class="line">    <span class="comment">// important: props need to be observed on the</span></div><div class="line">    <span class="comment">// v-for scope if present</span></div><div class="line">    scope: <span class="keyword">this</span>._scope</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// set the child initial value.</span></div><div class="line">initProp(child, prop, parentWatcher.value)</div><div class="line"></div><div class="line"><span class="comment">// setup two-way binding</span></div><div class="line"><span class="keyword">if</span> (twoWay) &#123;</div><div class="line">  <span class="comment">// important: defer the child watcher creation until</span></div><div class="line">  <span class="comment">// the created hook (after data observation)</span></div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">  child.$once(<span class="string">'pre-hook:created'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    self.childWatcher = <span class="keyword">new</span> Watcher(</div><div class="line">      child,</div><div class="line">      childKey,</div><div class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">        parentWatcher.set(val)</div><div class="line">      &#125;, &#123;</div><div class="line">        <span class="comment">// ensure sync upward before parent sync down.</span></div><div class="line">        <span class="comment">// this is necessary in cases e.g. the child</span></div><div class="line">        <span class="comment">// mutates a prop array, then replaces it. (#1683)</span></div><div class="line">        sync: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，监听 <code>prop</code> 的改动，是通过在 <code>parent</code> 对应的 <code>key</code> 上创建一个 <code>Watcher</code> 来实现的，一旦监听到数据变化就会更新 child 中对应 <code>prop</code> 的值。</p>
<p>如果是双向绑定，那么会在 <code>child</code> 上也对对应的 <code>prop</code> 创建一个 <code>Watcher</code>，当他变动的时候会设置 <code>parent</code> 中对应的值。</p>
<p>Watcher 本身应该也涉及到不少内容，所以对 watcher 的整个工作流程的讲解放到下一章。</p>
<p>看完 <code>props</code> 相关的代码之后就可以得出几个疑惑的结论：</p>
<p><em>疑问：解析 props 需要分析模板的字符串吗？</em></p>
<p>答案：不需要分析字符串， <code>this.el</code> 本来就是一个dom，用的就是 Dom 原生提供的 <code>getAttribute</code> 方法，这是 <code>util/dom.js</code> 中 <code>getAttr</code> 方法的定义，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAttr</span>(<span class="params">node, _attr</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> val = node.getAttribute(_attr);</div><div class="line">  <span class="keyword">if</span> (val !== <span class="literal">null</span>) &#123;</div><div class="line">    node.removeAttribute(_attr); <span class="comment">// 注意这里，取到值之后就把这个属性给删了，所以我们编译完组件之后就看不到在模板中定义的那些属性了</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>疑问：<code>.sync</code> 和 <code>.once</code> 是怎么解析的？</em></p>
<p>答案：很简单，假设 <code>props</code> 中定义了一个 <code>a</code> 属性，那么就把 <code>a</code>, <code>a.sync</code>, <code>a.once</code> 这三个 <code>attribute</code> 都尝试获取一下，先取到那个就用哪个。<br>所以定义了重复的属性会按照代码中的这个顺序覆盖哦, 比如先定义 <code>&lt;x a.sync=&quot;1&quot; a=&quot;2&quot;&gt;</code> 最终取到的会是 <code>2</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((value = getBindAttr(el, attr)) === <span class="literal">null</span>) &#123;</div><div class="line">  <span class="keyword">if</span> ((value = getBindAttr(el, attr + <span class="string">'.sync'</span>)) !== <span class="literal">null</span>) &#123;</div><div class="line">    prop.mode = propBindingModes.TWO_WAY</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((value = getBindAttr(el, attr + <span class="string">'.once'</span>)) !== <span class="literal">null</span>) &#123;</div><div class="line">    prop.mode = propBindingModes.ONE_TIME</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结下 <code>props</code> 处理的流程</p>
<ol>
<li>词法解析，把模板中的原始值做简单的处理，分理出 <code>value</code> 和 <code>filter</code></li>
<li>对每一个 <code>prop</code> 创建一个 <code>Directive</code> 负责处理数据更新</li>
<li>Directive 内部通过创建 <code>Watcher</code> 来实现对数据更新的监听</li>
</ol>
<h2 id="如何debug"><a href="#如何debug" class="headerlink" title="如何debug"></a>如何debug</h2><p>补充一下如何debug vue 的源码，参考 <a href="https://vuejs.org/guide/installation.html" target="_blank" rel="external">guide - install</a> 中 <code>Dev Build</code> 小节中的方法，自己clone并编译代码，然后在 chrome 开发者工具中按 <code>command + O</code> 打开 <code>vue.common.js</code>，就可以在其中下断点调试。</p>
<p>Next：分析 Watcher 工作流程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lihongxun945.github.io/blog/blog/2016/09/14/devide-into-vue-2/" data-id="cit2nagrx0000136wd7bvxfp3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/blog/2016/09/13/devide-into-vue-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">vue 源码解析一 - 框架和文件结构</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/vue/">vue</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/vue/" style="font-size: 10px;">vue</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/09/14/devide-into-vue-2/">vue 源码解析二 - instance</a>
          </li>
        
          <li>
            <a href="/blog/2016/09/13/devide-into-vue-1/">vue 源码解析一 - 框架和文件结构</a>
          </li>
        
          <li>
            <a href="/blog/2016/08/05/about-this-blog/">关于本博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 言川<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
    <a href="https://github.com/lihongxun945/blog" class="mobile-nav-link">github</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>
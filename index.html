<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>言川的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="言川的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="言川的博客">
<meta property="og:url" content="https://lihongxun945.github.io/blog/index.html">
<meta property="og:site_name" content="言川的博客">
<meta property="og:description" content="言川的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="言川的博客">
<meta name="twitter:description" content="言川的博客">
  
    <link rel="alternate" href="/atom.xml" title="言川的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">言川的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
          <a class="main-nav-link" href="https://github.com/lihongxun945/blog">github</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lihongxun945.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-curl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/09/20/curl/" class="article-date">
  <time datetime="2016-09-20T08:36:23.000Z" itemprop="datePublished">2016-09-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/09/20/curl/">curl 模拟ajax请求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用 <code>curl</code> 可以模拟各种http请求:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">curl -i \</div><div class="line">-H <span class="string">"Content-Type: application/json"</span> \</div><div class="line">--data <span class="string">'&#123;username:"test010",password:"123456"&#125;'</span> \</div><div class="line">http://192.168.1.2:q/login</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lihongxun945.github.io/blog/blog/2016/09/20/curl/" data-id="citfdxbi800011r6w2pgjwu7h" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/curl/">curl</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-devide-into-vue-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/09/15/devide-into-vue-3/" class="article-date">
  <time datetime="2016-09-15T02:41:00.000Z" itemprop="datePublished">2016-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/09/15/devide-into-vue-3/">vue 源码解析三 - Watcher</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇讲了对 <code>props</code> 的监听是通过创建 <code>Directive</code> 实现的，而 <code>Directive</code> 内部则创建了一个 <code>Watcher</code>。我们现在来看看 <code>Wacher</code> 是如何监听数据的更新的。</p>
<h2 id="如何关联-props-xxx-和-this-xxx"><a href="#如何关联-props-xxx-和-this-xxx" class="headerlink" title="如何关联 props.xxx 和 this.xxx"></a>如何关联 <code>props.xxx</code> 和 <code>this.xxx</code></h2><p>在 <code>watcher.js</code> 中我们看不到任何使用 ES6 相关API来监听属性更新的，反而能看到这么一行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Watcher</span> (<span class="params">vm, expOrFn, cb, options</span>) </span>&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  vm._watchers.push(<span class="keyword">this</span>) <span class="comment">// 这一行代码</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这行代码是在每次创建一个 <code>watcher</code> 实例后都会把这个实例放进 <code>vm._watchers</code> 中保存。这里的 <code>vm</code> 就是 <code>Vue</code> 的一个实例。</p>
<p>那么显然，并不是每一个watcher去自己监听 vm 的数据更新，而是 <code>wachter</code> 通过这种方式把自己注册到 <code>vm</code> 上，当有数据更新的时候，由 <code>vm</code> 负责调用 <code>watcher</code> 来更新数据。</p>
<p>接着上一篇，我们继续看 <code>compileProps</code> 方法，他最后返回的是另一个方法的结果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> makePropsLinkFn(props)</div></pre></td></tr></table></figure>
<p>最终调用了 <code>defineReactive</code> 方法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defineReactive(vm, prop.path, value)</div></pre></td></tr></table></figure>
<p>这个方法中，会把前面定义的每一个 <code>prop</code> 都在 <code>vm</code> 对象上做一个 <code>reactive</code> 的同名 <code>prop</code>，因此我们才能把 <code>this.show = true</code> 和 <code>props.show</code> 关联起来。</p>
<p>这里贴一下简化版的 <code>defineReactive</code> 方法实现，完整版请在 <code>observer/index.js</code> 中查看。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> Dep()</div><div class="line"></div><div class="line">  <span class="keyword">var</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</div><div class="line"></div><div class="line">  <span class="keyword">var</span> childOb = observe(val)</div><div class="line"></div><div class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</div><div class="line">    enumerable: <span class="literal">true</span>,</div><div class="line">    configurable: <span class="literal">true</span>,</div><div class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val</div><div class="line">      <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> value</div><div class="line">    &#125;,</div><div class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> value = getter ? getter.call(obj) : val</div><div class="line">      <span class="keyword">if</span> (newVal === value) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (setter) &#123;</div><div class="line">        setter.call(obj, newVal)</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        val = newVal</div><div class="line">      &#125;</div><div class="line">      childOb = observe(newVal)</div><div class="line">      dep.notify()</div><div class="line">    &#125;</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里对闭包的应用，<code>getter</code> 和 <code>setter</code> 都是操作这个函数闭包中的 <code>val</code> 变量，这个变量的初始值其实就是我们初始化的时候传入的 <code>props</code> 中对应的值。</p>
<p>这样我们就弄清楚了为什么 <code>props.xxx</code> 可以和 <code>vm.xxx(this.xxx)</code> 关联起来。</p>
<p>也能清楚 <code>this.xxx = xxx</code> 是怎么工作的，其实 <code>this.xxx</code> 会调用上面的 <code>set</code> 方法，他会把一个闭包中的变量 <code>val</code> 修改掉，这样下次我们通过 <code>this.xxx</code> 取值的时候，就会取到新的 <code>val</code> 值。</p>
<p>有兴趣的童鞋可以在 <code>get</code> 和 <code>set</code> 方法中下断点，然后修改一下props的值来验证。</p>
<p>到目前为止，我们清楚了 <code>props.xxx</code> 和 <code>this.xxx</code> 是如何关联的，下一步，我们就要弄清楚，从 <code>this.xxx = xxx</code> 是如何触发 DOM 的更新的。</p>
<h2 id="更新-DOM"><a href="#更新-DOM" class="headerlink" title="更新 DOM"></a>更新 DOM</h2><p>先看看上面 <code>defineReactive</code> 中省略的一行关键代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</div><div class="line">  <span class="keyword">if</span> (Dep.target) &#123;</div><div class="line">    dep.depend(); <span class="comment">// 关键代码</span></div><div class="line">    <span class="keyword">if</span> (childOb) &#123;</div><div class="line">      childOb.dep.depend();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (isArray(value)) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> e, i = <span class="number">0</span>, l = value.length; i &lt; l; i++) &#123;</div><div class="line">        e = value[i];</div><div class="line">        e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> value;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>其中 <code>dep.depend()</code> 这行代码定义了对这个属性的 <code>依赖</code>，其中 <code>更新DOM</code> 就是一种依赖（另一种依赖就是更新 <code>children.props.xxx</code>）。他最终会把当前这个属性的 <code>watcher</code> 存到 <code>dep.subs</code> 中。具体过程有兴趣的可以断点跟踪一下，过程并不复杂，要注意其中 <code>Deo.target</code> 就是当前属性对应的 <code>watcher</code>。</p>
<p>所以在 <code>set</code> 函数中，最后一行 <code>dep.notify()</code> 就会触发对应的 <code>依赖</code>，也就是对 DOM 的更新。</p>
<p>这里说一下大致的流程：</p>
<ol>
<li><code>dep.notify()</code> 会触发对应的 <code>wachter.run()</code></li>
<li><code>watcher.run()</code> 的时候会触发对应的 <code>directive._update()</code></li>
<li>最终由对应的 <code>directive</code> 负责完成DOM更新，比如是一个 <code>textNode</code> 那么最终是由 <code>directives/public/text.js</code> 中的 <code>update</code> 方法完成更新的</li>
</ol>
<p><img src="/blog/images/props-workflow.png" alt="vue-props-workflow"></p>
<p>注意到这里了吗，前一章说过，对每一个 <code>prop</code> 都会创建一个 <code>directive</code>， <code>directive</code> 内部则创建了一个 <code>watcher</code> 来监听 prop 的更新，一旦监听到更新就会执行 <code>directive.update</code> 来更新 DOM。</p>
<p>大致的流程就是这样的，当然实际上代码比这个复杂很多，这里只是说一个最简单的流程。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lihongxun945.github.io/blog/blog/2016/09/15/devide-into-vue-3/" data-id="citfdxbik00051r6we8dn48hb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-devide-into-vue-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/09/14/devide-into-vue-2/" class="article-date">
  <time datetime="2016-09-14T02:41:00.000Z" itemprop="datePublished">2016-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/09/14/devide-into-vue-2/">vue 源码解析二 - instance</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们从 <code>instance/vue.js</code> 开始:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._init(options)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// install internals</span></div><div class="line">initMixin(Vue)</div><div class="line">stateMixin(Vue)</div><div class="line">eventsMixin(Vue)</div><div class="line">lifecycleMixin(Vue)</div><div class="line">miscMixin(Vue)</div><div class="line"></div><div class="line"><span class="comment">// install instance APIs</span></div><div class="line">dataAPI(Vue)</div><div class="line">domAPI(Vue)</div><div class="line">eventsAPI(Vue)</div><div class="line">lifecycleAPI(Vue)</div></pre></td></tr></table></figure>
<p>上面这段就是 <code>vue.js</code> 中的代码，可以看到对 <code>Vue</code> 这个类的定义包含三部分：</p>
<ul>
<li><code>_init</code> 函数,做一些初始化操作，如处理父子关系，解析<code>option</code>, 启动HTML解析等</li>
<li><code>mixin</code> 大部分功能的实现都在这里</li>
<li><code>api</code> 全部的接口封装都在这里，而这些接口中部分的实现依然在 <code>mixin</code> 中</li>
</ul>
<h2 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h2><p>init 函数主要做了这么些工作：</p>
<ol>
<li>处理组件层级关系： <code>$parent, $chilren, $root</code></li>
<li>初始化内部变量：<code>_directives, _events, _isFragment</code> lifecircle 相关标记等</li>
<li>合并 <code>options</code>：把初始化函数传入的 <code>options</code> 和 <code>Vue.options</code> 合并，<code>Vue.options</code> 我们后续会在 global 章节详细讲解</li>
<li>调用其他模块的初始化：<code>_initState, _initEvents</code></li>
<li>启动lifecircle: <code>this.$mount</code></li>
</ol>
<p>我们这里不会每一行代码都讲到，毕竟像怎么进行 <code>dom</code> 这种并不是vue的核心所在，下面我们重点看两个关键部分：<code>数据绑定</code> 和 <code>模板更新</code></p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p><code>internal/state.js</code> 中对数据的处理代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Vue.prototype._initState = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>._initProps()</div><div class="line">  <span class="keyword">this</span>._initMeta()</div><div class="line">  <span class="keyword">this</span>._initMethods()</div><div class="line">  <span class="keyword">this</span>._initData()</div><div class="line">  <span class="keyword">this</span>._initComputed()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是 <code>state</code> 包含了五个部分：<code>props, meta, methods, data, computed</code>, 我们以 <code>props</code> 为切入点来看看数据绑定是如何工作的。</p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>对 <code>props</code> 的处理，最终在 <code>src/compiler/compile-props.js</code> 中的 <code>compileProps</code> 方法中实现，这个方法过程如下：</p>
<p>第一步，对 <code>props</code> 做预处理，主要是词法分析和类型检测：</p>
<p>遍历 <code>propOptions</code> 的key，这个 <code>propOptions</code> 就是初始化传入的 <code>props</code>，然后对每一个 key 做如下操作(在循环体中叫<code>name</code>)：</p>
<ol>
<li>检查name是否是合法的标识符</li>
<li>根据 name 从 el 上取出绑定的原始值 <code>value</code>，同时会根据 <code>.sync</code> 和 <code>.once</code> 打上对应的标签</li>
<li>调用 <code>parseDirective</code> 方法解析 <code>value</code>，注意这只是一个简单的词法分析，对 <code>value</code> 做了一个切分，分出其中的 <code>expression</code> 和 <code>filter</code>，而这个 <code>expression</code> 依然是一个字符串。注意从这一步开始 <code>value</code> 和 <code>filters</code> 被分割开了</li>
<li>检查 <code>value</code> 是否是一个简单的字面量，如果是一个字面量就会打上一个 <code>optimizedLiteral</code> 标签，后序就不用处理绑定了。字面量就是以字面量形式写出的：<code>true</code>, <code>false</code>, 数字 和 字符串</li>
</ol>
<p>第一步完成后得到了一个合法的，经过初步处理的 <code>props</code> 数组。然后我们来进行第二步处理.</p>
<p>第二步主要就是把 <code>value</code> 解析出来。</p>
<p>第二步依然是一个循环处理，对第一步得到的 <code>props</code> 数组循环处理，主要是对每一个 <code>prop</code> 创建一个对应的 <code>Directive</code>：</p>
<ol>
<li>遍历 <code>props</code> 取出一个 <code>prop</code></li>
<li>在 <code>_context</code> 上进行绑定，这个 <code>_context</code> 一般就是父组件。</li>
<li>绑定的过程其实是创建了一个 <code>Directive</code>，这个 <code>Directive</code> 的 <code>descriptor</code> 如下：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  name: <span class="string">'prop'</span>,</div><div class="line">  prop: prop,</div><div class="line">  def: &#123;</div><div class="line">    bind: <span class="function"><span class="keyword">function</span>,</span></div><div class="line">    <span class="title">unbind</span>: <span class="title">function</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中 <code>bind</code> 和 <code>unbind</code> 是在 <code>directives/internal/prop.js</code> 中定义的。</p>
<p>到这一步我们可以明白了，对每一个 <code>prop</code> 的绑定，其实是创建了一个专门处理 <code>prop</code> 的 <code>directive</code>。那么这个 <code>directive</code> 中显然主要是处理监听的，我们继续往下看。</p>
<p>第三步，在 <code>Directive</code> 内创建 <code>watcher</code> 来监听数据更新。</p>
<p>在 <code>bind</code> 函数中创建 <code>Watcher</code> 的代码比较简洁，直接贴出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> parentWatcher = <span class="keyword">this</span>.parentWatcher = <span class="keyword">new</span> Watcher(</div><div class="line">  parent,</div><div class="line">  parentKey,</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">    updateProp(child, prop, val)</div><div class="line">  &#125;, &#123;</div><div class="line">    twoWay: twoWay,</div><div class="line">    filters: prop.filters,</div><div class="line">    <span class="comment">// important: props need to be observed on the</span></div><div class="line">    <span class="comment">// v-for scope if present</span></div><div class="line">    scope: <span class="keyword">this</span>._scope</div><div class="line">  &#125;</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment">// set the child initial value.</span></div><div class="line">initProp(child, prop, parentWatcher.value)</div><div class="line"></div><div class="line"><span class="comment">// setup two-way binding</span></div><div class="line"><span class="keyword">if</span> (twoWay) &#123;</div><div class="line">  <span class="comment">// important: defer the child watcher creation until</span></div><div class="line">  <span class="comment">// the created hook (after data observation)</span></div><div class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span></div><div class="line">  child.$once(<span class="string">'pre-hook:created'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    self.childWatcher = <span class="keyword">new</span> Watcher(</div><div class="line">      child,</div><div class="line">      childKey,</div><div class="line">      <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</div><div class="line">        parentWatcher.set(val)</div><div class="line">      &#125;, &#123;</div><div class="line">        <span class="comment">// ensure sync upward before parent sync down.</span></div><div class="line">        <span class="comment">// this is necessary in cases e.g. the child</span></div><div class="line">        <span class="comment">// mutates a prop array, then replaces it. (#1683)</span></div><div class="line">        sync: <span class="literal">true</span></div><div class="line">      &#125;</div><div class="line">    )</div><div class="line">  &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，监听 <code>prop</code> 的改动，是通过在 <code>parent</code> 对应的 <code>key</code> 上创建一个 <code>Watcher</code> 来实现的，一旦监听到数据变化就会更新 child 中对应 <code>prop</code> 的值。</p>
<p>如果是双向绑定，那么会在 <code>child</code> 上也对对应的 <code>prop</code> 创建一个 <code>Watcher</code>，当他变动的时候会设置 <code>parent</code> 中对应的值。</p>
<p>Watcher 本身应该也涉及到不少内容，所以对 watcher 的整个工作流程的讲解放到下一章。</p>
<p>看完 <code>props</code> 相关的代码之后就可以得出几个疑惑的结论：</p>
<p><em>疑问：解析 props 需要分析模板的字符串吗？</em></p>
<p>答案：不需要分析字符串， <code>this.el</code> 本来就是一个dom，用的就是 Dom 原生提供的 <code>getAttribute</code> 方法，这是 <code>util/dom.js</code> 中 <code>getAttr</code> 方法的定义，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAttr</span>(<span class="params">node, _attr</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> val = node.getAttribute(_attr);</div><div class="line">  <span class="keyword">if</span> (val !== <span class="literal">null</span>) &#123;</div><div class="line">    node.removeAttribute(_attr); <span class="comment">// 注意这里，取到值之后就把这个属性给删了，所以我们编译完组件之后就看不到在模板中定义的那些属性了</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> val;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>疑问：<code>.sync</code> 和 <code>.once</code> 是怎么解析的？</em></p>
<p>答案：很简单，假设 <code>props</code> 中定义了一个 <code>a</code> 属性，那么就把 <code>a</code>, <code>a.sync</code>, <code>a.once</code> 这三个 <code>attribute</code> 都尝试获取一下，先取到那个就用哪个。<br>所以定义了重复的属性会按照代码中的这个顺序覆盖哦, 比如先定义 <code>&lt;x a.sync=&quot;1&quot; a=&quot;2&quot;&gt;</code> 最终取到的会是 <code>2</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((value = getBindAttr(el, attr)) === <span class="literal">null</span>) &#123;</div><div class="line">  <span class="keyword">if</span> ((value = getBindAttr(el, attr + <span class="string">'.sync'</span>)) !== <span class="literal">null</span>) &#123;</div><div class="line">    prop.mode = propBindingModes.TWO_WAY</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((value = getBindAttr(el, attr + <span class="string">'.once'</span>)) !== <span class="literal">null</span>) &#123;</div><div class="line">    prop.mode = propBindingModes.ONE_TIME</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结下 <code>props</code> 处理的流程</p>
<ol>
<li><em>词法解析</em>，把模板中的原始值做简单的处理，分理出 <code>value</code> 和 <code>filter</code></li>
<li><em>创建derctive</em>, 对每一个 <code>prop</code> 创建一个 <code>Directive</code> 负责处理数据更新</li>
<li><em>创建watcher</em>, Directive 内部通过创建 <code>Watcher</code> 来实现对数据更新的监听</li>
</ol>
<p><img src="/blog/images/props-init.png" alt="vue-props-init"></p>
<h2 id="如何debug"><a href="#如何debug" class="headerlink" title="如何debug"></a>如何debug</h2><p>补充一下如何debug vue 的源码，参考 <a href="https://vuejs.org/guide/installation.html" target="_blank" rel="external">guide - install</a> 中 <code>Dev Build</code> 小节中的方法，自己clone并编译代码，然后在 chrome 开发者工具中按 <code>command + O</code> 打开 <code>vue.common.js</code>，就可以在其中下断点调试。</p>
<p>Next：分析 Watcher 工作流程</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lihongxun945.github.io/blog/blog/2016/09/14/devide-into-vue-2/" data-id="citfdxbih00041r6wdwtci2ei" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-devide-into-vue-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/09/13/devide-into-vue-1/" class="article-date">
  <time datetime="2016-09-13T02:41:00.000Z" itemprop="datePublished">2016-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/09/13/devide-into-vue-1/">vue 源码解析一 - 框架和文件结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近一直在埋头写代码，两个开源项目基本占用了全部时间。子曰<code>学而不思则罔，思而不学则殆</code>，无论再忙还是要抽出时间来学习和思考，埋头写代码而不知思考是不会有太大进步的。</p>
<p>在新博客上就以 vue 源码解析系列来开篇吧，因为是边看边写文章的顺序基本是按照自己看源码的顺序来的，效果可能比不上先完整看一遍再写（并不会现有一个对代码结构很透彻的理解再逐步解析每个模块）。</p>
<p>这里我们以 <code>v1.0.26</code> 为基础开始看源码，全部看完一遍以后，会继续看 <code>v2.0</code> 的源码，并比较其中的差异。建议看这篇博客的读者都自行clone源码并切换到 <code>v1.0.26</code> tag。</p>
<h1 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h1><p>从入口文件 <code>/src/index.js</code> 入手，顺序捋一遍，vue的大概结构如下：</p>
<p><img src="/blog/images/vue-structure.png" alt="vue-structure"></p>
<p>vue的源码结构分为 <code>Instance</code> 和 <code>Global</code> 两大块，下面我们分别粗略的看看这两个部分</p>
<h2 id="Instance"><a href="#Instance" class="headerlink" title="Instance"></a>Instance</h2><p>其中 <code>Instance</code> 就是对 Vue 实例的定义，也就是定义了 <code>Vue</code> 这个类本身，我们通过 <code>new Vue</code> 来生成实例。</p>
<p><code>Vue</code> 类的定义在 <code>instance</code> 文件夹下，主要包括两方面内容：</p>
<ul>
<li><p><code>internal</code> 文件夹下定义的是 <code>Vue</code> 内部的方法，内部方法全部以 <code>_</code> 开头(所以要避免使用 <code>_</code> 开头的方法和属性)</p>
<ul>
<li><code>init</code> 定义了一些初始化操作，比如对 <code>$parent</code> <code>$children</code> 的初始化，<code>$mount</code>, 调用 <code>events</code> 等其他初始化方法</li>
<li><code>events</code> 处理 我们初始化的时候传入的<code>events</code> 和 <code>watch</code> 参数</li>
<li><code>lifecircle</code> 实现了从初始化到销毁的整个生命周期</li>
<li><code>state</code> 主要处理 <code>props</code> 和 <code>data</code>，定义了对他们的 <code>watcher</code> 来监听数据变动</li>
</ul>
</li>
<li><p><code>api</code> 文件夹下定义的是实例的接口，是我们可以在实例上调用的方法，全部以 <code>$</code> 开头</p>
<ul>
<li><code>data</code> 定义了对数据的操作： <code>$get, $set, $watch, $delete</code>等</li>
<li><code>dom</code> 定义了几个常用的dom操作： <code>$before, $after</code>等，还有最常用的 <code>$nextTick</code> 也定义在这里</li>
<li><code>events</code> 定义了事件接口：<code>$on, $emit, $broadcast</code> 等</li>
<li><code>lifecircle</code> 定义了和生命周期相关的接口：<code>$mount, $compile, $destroy</code><br>-</li>
</ul>
</li>
</ul>
<p>要注意的是，<code>internal</code> 和 <code>api</code> 中都涉及到了对 <code>data</code> 和 <code>events</code> 的处理，他们是有严格区别的，<code>internal</code> 下都是内部初始化用的，比如如何初始化用户传入的 <code>data</code> ，而<code>api</code> 下面都是提供实例接口的，<code>api</code> 下面定义的接口都不包含具体实现，具体的实现都是在 <code>internal</code> 中的。</p>
<h2 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h2><p>Global 的入口文件是 <code>global-api.js</code>，定义了 <code>directives</code>, <code>filters</code>, <code>transition</code>, <code>parser</code> 等全局模块，定义了 <code>Vue</code> 上的静态属性</p>
<ul>
<li>directives 分两类：<ul>
<li>elementDirectives 只有两个 <code>slot</code> 和 <code>partical</code></li>
<li>public directives 包含了其余所有的，比如 <code>bind</code>, <code>for</code>, <code>if</code> 等</li>
</ul>
</li>
</ul>
<p><code>instance</code> 和 <code>global-api</code> 最终还依赖了 <code>compiler</code>, <code>observer</code>, <code>parser</code>, <code>utils</code> 等模块。</p>
<p><code>global</code> 相关的我们留在 <code>instance</code> 后面再看。</p>
<p>下一章，我们从 <code>instance</code> 的整个生命周期入手，来看看一个组件从初始化到销毁都经历了哪些步骤，每个步骤是怎么设计的，重点应该是 <code>数据监听</code> 和 <code>模板渲染</code> 两部分</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lihongxun945.github.io/blog/blog/2016/09/13/devide-into-vue-1/" data-id="citfdxbib00021r6wq7v29e6b" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-about-this-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016/08/05/about-this-blog/" class="article-date">
  <time datetime="2016-08-05T09:40:19.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/08/05/about-this-blog/">关于本博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关于本博客"><a href="#关于本博客" class="headerlink" title="关于本博客"></a>关于本博客</h1><p>在CSDN上断断续续写了5年博客，发表了上百篇原创文章，涉及了<em>前端，算法，Java，安卓，Linux</em> 等各种领域。<br>一直想切换到github上，近期发生了一些不愉快的事情，机缘巧合下也正好把博客搬家到github上。<br>至于为什么在github上写博客，而不是在CSDN等博客网站上写，大约主要是如下原因：</p>
<ul>
<li>本人是github重度用户，所有能放在github上基本都不愿意放在别处</li>
<li>github 上用markdown写起来更方便</li>
<li>独立博客更自由，可以自定义域名，可以自己设计页面</li>
<li>以前的博客写的很杂，希望换一个地方专心写一些比较高质量的技术博客</li>
</ul>
<p>此博客源码：<a href="https://github.com/lihongxun945/blog" target="_blank" rel="external">https://github.com/lihongxun945/blog</a><br>旧的博客地址: <a href="http://blog.csdn.net/lihongxun945?viewmode=contents" target="_blank" rel="external">http://blog.csdn.net/lihongxun945?viewmode=contents</a></p>
<h1 id="关于作者-言川"><a href="#关于作者-言川" class="headerlink" title="关于作者@言川"></a>关于作者@言川</h1><p>前端工程师，开源爱好者。目前个人开源项目主要有：</p>
<ul>
<li>微信公众账号开发UI库 <a href="https://github.com/lihongxun945/jquery-weui" target="_blank" rel="external">jQuery WeUI</a></li>
<li>正在开发的基于VUE的UI框架 <a href="https://github.com/lihongxun945/vum" target="_blank" rel="external">VUM</a></li>
</ul>
<p>另外还有一些公司的开源项目就不在这里列出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lihongxun945.github.io/blog/blog/2016/08/05/about-this-blog/" data-id="citfdxbi300001r6w1qv1ieto" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/curl/">curl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/blog/tags/vue/">vue</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/curl/" style="font-size: 10px;">curl</a> <a href="/blog/tags/vue/" style="font-size: 20px;">vue</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Arkiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2016/08/">August 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2016/09/20/curl/">curl 模拟ajax请求</a>
          </li>
        
          <li>
            <a href="/blog/2016/09/15/devide-into-vue-3/">vue 源码解析三 - Watcher</a>
          </li>
        
          <li>
            <a href="/blog/2016/09/14/devide-into-vue-2/">vue 源码解析二 - instance</a>
          </li>
        
          <li>
            <a href="/blog/2016/09/13/devide-into-vue-1/">vue 源码解析一 - 框架和文件结构</a>
          </li>
        
          <li>
            <a href="/blog/2016/08/05/about-this-blog/">关于本博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 言川<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
    <a href="https://github.com/lihongxun945/blog" class="mobile-nav-link">github</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

  </div>
</body>
</html>